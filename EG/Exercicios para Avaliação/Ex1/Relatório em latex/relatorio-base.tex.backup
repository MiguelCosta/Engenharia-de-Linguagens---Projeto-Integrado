\documentclass[a4paper]{article}
\usepackage[portuguese]{babel}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fancyvrb}
\usepackage{url}
\usepackage{graphicx}
\usepackage{float}

%\usepackage{aeguill}  % usefull for pdflatex
\usepackage[compat2,a4paper,twosideshift=0mm,left=20mm,right=20mm,bottom=20mm,top=15mm]{geometry}

\parindent=2em


\title{Mestrado em Engenhraria Informática \\ UCE30: Engenharia de Linguagens \\ Módulo: Engenhraria Gramatical\\ Exercício para Avaliação n.º 1  }
\author{Bruno Azevedo \and Miguel Costa}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Este documento apresenta a resolução do Exercício Prático n.º 1 do módulo de Engenharia de Linguagens.
O exercício está relacionado com Gramática Independente de Contexto e Gramática de Atributos para resolver um problema
de cálculo de elementos mistos (palavras e números).
\end{abstract}

\newpage

\parskip=0mm
\tableofcontents
\parskip=2mm

\newpage

\section{Introdução}
Uma introdução começa normalmente com a apresentação do problema
que se pretende resolver e sua contextualização (o
``enquadramento``).

No caso deste relatório, é um documento de treino das capacidades
de comunicação escrita dos estudantes do 1º ano de informática da
UM, que tem também como objectivo relatar as diversas fases por
que o grupo de trabalho teve de passar para chegar ao resultado
final na resolução de um dado problema, apresentado como o
''Projecto``. Este relatório faz parte integrante do projecto da
disciplina de PP2 (LESI) e do projecto do par de disciplinas PI+AC
(LMCC, com a designação de ''Projecto Integrado``).

Uma vez elaborado, em LaTeX, o relatório e respectivos anexos (se
existirem) deverão ser compilados para PDF. O conjunto de
ficheiros resultantes, LaTeX, PDF e os ficheiros de código e
respectivos dados (de entrada e/ou de teste) deverão ser colocados
numa pasta e esta compactada (formato ZIP). O ficheiro resultante
deverá então ser submetido electronicamente em
\url{http://nirvana.di.uminho.pt/labdotnet/Submit_PP2_PI_AC_0506}. Se
alguém tiver que submeter o seu trabalho enquanto membro de mais
que um grupo (um para PI, outro para AC), deverá contactar
directamente o docente de AC.

A introdução termina normalmente com uma apresentação da estrutura
do relatório, e o que aqui se apresenta é apenas um exemplo para a
fase 1 do projecto. A Secção 2 caracteriza o ambiente de trabalho,
quer em termos de equipamento, quer ainda de sistema operativo e
aplicações usadas. A Secção 3 descreve e analisa o problem a
resolver, especificando ainda os seus requisitos. A Secção 4
propõe uma solução para o problema, em termos de algoritmos e
estruturas de dados a usar, enquanto a Secção seguinte descreve
sumariamente as alternativas e decisões tomadas na codificação da
resolução e consequentes testes e resultados obtidos. O relatório
termina com uma Secção de Conclusões, onde se discutem de uma
forma crítica os resultados gerais elaboração do trabalho.

Comentários adicionais: o Resumo deverá apenas conter uma
descrição resumida do conteúdo do relatório, e não mais que 1/3
deverá ser usado para contextualizar o problema; se forem
consultadas obras bibliográficas que merecem ser referidas ou
sítios na Web que merecem algum destaque, deverá ser criada uma
nova Secção ''Referências``, não numerada, após as ''Conclusões``,
contendo uma lista numerada dessas referências, ordenada pela
ordem com que surgem no texto.

\section{Ambiente de Trabalho}
Tal como seria de esperar, um exercício deste tipo é resolvido
inicialmente em papel, para ser mais fácil estruturar o problema e 

Nesta secção descreve-se o ambiente de trabalho que se utilizou na
resolução do problema. Esta descrição deverá incluir todos os
detalhes pertinentes para garantir a reprodutibilidade das
condições de teste utilizadas no esforço de obtenção de uma
solução do problema.

A fase final do projecto conterá uma componente relevante
relacionada com avaliação de desempenho, pelo que se deverá
incluir todas as características do sistema computacional que
possam ter algum impacto no desempenho.

Dever-se-á ainda incluir a caracterização de todo o software que
for utilizado, desde o sistema operativo aos utilitários de
desenvolvimento (não esquecer as versões).

\section{Descrição informal do problema}
Era pretendido que se usasse o processador da Lista de Elementos Mistos (palavras e inteiros), 
que foi desenvolvido nas aulas, e alterar a sua Gramática de Atributos (GA) de modo a calcular o 
somatório de cada sequência se inteiros que surjam a seguir à palavra ?soma?.

Exemplo:
\begin{verbatim}
        A frase ''[a,1,2,b,soma,3,a,4,soma,b,2,7]``
        Dá como resultado: [7,9]  
\end{verbatim}


\section{Resolução no papel}
\subsection{Gramática Independente do Contexto}
Observando o problema formulámos a seguinte Gramática Independente do Contexto (GIC):
\begin{verbatim}
GIC = (T, N, S, P)
Símbolos terminais (T):         {str, int, '[' , ']', ','}
Símbolos não terminais (N):     {Lista, Elementos, Elemento}
Símbolo Inicial (S):            Lista
Produções (P):
                                P0: Lista       -> '[' Elementos ']'
                                P1: Elementos   -> Elemento 
                                P2:             | Elemento ',' Elementos
                                P3: Elemento    -> int
                                P4:             | str

                                str = [a-zA-Z]+
                                int = [0-9]+
\end{verbatim}

\subsection{Gramática de Atributos}
 Depois de definida e analisada a GIC, definimos a Gramática de Atributos como:
\verb|GA = (GIC, A, RC, CC, RT)|    

Para resolver este problema, usamos 3 variáveis:
\begin{itemize}
\item \verb|sum|
\item \verb|sum_flag|
\item \verb|result|
\end{itemize}

A variável \verb|sum_flag| é inicializada a 0 e quando for encontrada a palavra ``soma'' 
fica 1 e coloca a variável \verb|sum| a 0, a partir deste momento quando encontrar um elemento inteiro 
vai adiciona-lo a \verb|sum|.
Result é um array que vai conter o resultado, ele é alterado quando se encontrada a palavra ``soma'' 
e a variável \verb|sum| é maior que 0, vai ficar: \verb|result = result.add(sum)|.

Os símbolos não terminais podem ter atributos sintetizados e herdados, por isso, a forma que encontramos 
para resolver o problema de saber quando adicionar ao array \verb|result| o sum foi dizer que os símbolos não terminais tem:
\begin{itemize}
 \item Atributos sintetizados
 \subitem \verb|out_sum|
 \subitem \verb|out_sum_flag|
 \subitem \verb|out_result|
 \item Atributos herdados
 \subitem \verb|in_sum|
 \subitem \verb|in_sum_flag|
 \subitem \verb|in_result|
\end{itemize}

O que é pretendido com esta solução, é que o símbolo não terminal receba a informação do estado 
atual (atributos in) e depois devolva a informação atualizada  (atributos out).

\subsubsection{Atributos (A)}
\begin{verbatim}
Lista           result : ArrayList<Integer>

Elementos       in_result : ArrayList<Integer>
                out_result : ArrayList<Integer>
                in_sum : int
                out_sum : int
                in_sum_flag : int
                out_sum_flag :int

Elemento        in_result : ArrayList<Integer>
                out_result : ArrayList<Integer>
                in_sum : int
                out_sum : int
                in_sum_flag : int
                out_sum_flag :int
\end{verbatim}

\subsubsection{Regra de Cálculo (RC), Condição Contextual (CC) e Regra de Tradução (RT)}

\VerbatimInput{1.txt}


\section{Resolução no VisualLisa}
Este problema foi também resolvido visualmente com a ajuda da ferramenta VisualLisa.
Esta seção mostra como ficou resolvido visualmente o exercício.

\subsection{Produções}
As \verb|Produções (P)|:
\begin{verbatim}
                P0: Lista       -> '[' Elementos ']'
                P1: Elementos   -> Elemento 
                P2:             | Elemento ',' Elementos
                P3: Elemento    -> int
                P4:             | str
\end{verbatim}

da gramática independente de contexto que já está definida, 
quando representada visualmente em VisualLisa fica como a Figura 1.

\begin{figure}[H]
 \centering
 \includegraphics[scale=0.7]{./imag1.png}
 % imag1.png: 438x220 pixel, 72dpi, 15.45x7.76 cm, bb=0 0 438 220
 \caption{Produções}
\end{figure}

\subsubsection{Lista -> Elementos}
A produção Lista -> Elementos visualmente fica como mostra a Figura 2, 
em que também já aparecem os atributos de cada símbolo.

\begin{figure}[H]
 \centering
 \includegraphics[scale=0.6]{./imag2.png}
 % imag2.png: 688x477 pixel, 72dpi, 24.27x16.83 cm, bb=0 0 688 477
 \caption{Produção P0}
\end{figure}


\subsubsection{Elementos -> Elemento}
\begin{figure}[H]
 \centering
 \includegraphics[scale=0.6]{./imag3.png}
 % imag3.png: 734x531 pixel, 72dpi, 25.89x18.73 cm, bb=0 0 734 531
 \caption{Produção P1}
\end{figure}


\subsubsection{Elementos -> Elemento ',' Elementos}
\begin{figure}[H]
 \centering
 \includegraphics[scale=0.6]{./imag4.png}
 \caption{Produção P2}
\end{figure}


\subsubsection{Elemento -> int}
\begin{figure}[H]
 \centering
 \includegraphics[scale=0.6]{./imag5.png}
 \caption{Produção P3}
\end{figure}

\subsubsection{Elemento -> str}
\begin{figure}[H]
 \centering
 \includegraphics[scale=0.6]{./imag6.png}
 \caption{Produção P4}
\end{figure}


\subsection{Regras}
\subsubsection{Lista -> Elementos}
\textbf{result}\\
Esta é a regra que devolve o resultado da frase que for dada para calcular e 
é calculada por: \verb|Lista.result = Elementos.result|
\begin{figure}[H]
 \centering
 \includegraphics[scale=0.6]{./imag7.png}
 \caption{Regra para Lista.result}
\end{figure}

\textbf{init}\\
O que é feito nesta regra é inicializar as variáveis \verb|in_sum| e \verb|in_sum_flag| a zero.
\begin{verbatim}
        Elementos.in_sum = 0
        Elementos.in_sum_flag = 0 
\end{verbatim}

\begin{figure}[H]
 \centering
 \includegraphics[scale=0.6]{./imag8.png}
 \caption{Regra para inicializar variáveis}
\end{figure}

\begin{figure}[H]
 \centering
 \includegraphics[scale=0.6]{./imag9.png}
 \caption{Função init}
\end{figure}


\subsubsection{Elementos -> Elemento}
\textbf{in out}\\
Aqui estão as regras:
\begin{verbatim}
        Elemento.in_result = Elementos.in_result
        Elemento.in_sum = Elementos.in_sum
        Elemento.in_sum_flag = Elementos.in_sum_flag
        Elementos.out_result = Elemento.out_result
        Elementos.out_sum = Elemento.out_sum
        Elementos.out_sum_flag = Elemento.out_sum_flag
\end{verbatim}

\begin{figure}[H]
 \centering
 \includegraphics[scale=0.6]{./imag10.png}
 \caption{Regras in out}
\end{figure}


\subsubsection{Elementos -> Elemento ',' Elementos}
\textbf{in}\\
Regras:
\begin{verbatim}
        Elemento.in_sum = Elementos0.in_sum
        Elemento.in_sum_flag = Elementos0.in_sum_flag
        Elemento.in_result = Elementos0.in_result
        Elementos1.in_sum = Elemento.out_sum
        Elementos1.in_sum_flag = Elemento.out_sum_flag
        Elementos1.in_result = Elemento.out_result
\end{verbatim}

\begin{figure}[H]
 \centering
 \includegraphics[scale=0.6]{./imag11.png}
 \caption{Regras in}
\end{figure}

\textbf{out}\\
\begin{verbatim}
        Elementos0.out_sum = Elementos1.out_sum
        Elementos0.out_sum_flag = Elementos1.out_sum_flag
        Elementos0.out_result = Elementos1.out_result
\end{verbatim}
\begin{figure}[H]
 \centering
 \includegraphics[scale=0.6]{./imag12.png}
 \caption{Regras out}
\end{figure}


\subsubsection{Elemento -> int}
\textbf{sum}\\
\begin{verbatim}
Elemento.out_sum = function refresh_sum 
\end{verbatim}
Em que a função é definida por:
\begin{verbatim}
        $1 = Elemento.in_sum, $2 = Elemento.in_sum_flag, $3 = str.value
        int refresh_sum($1,$2,$3){
                if($2==1) return $1+$3; else return $1; 
        }
\end{verbatim}
\begin{figure}[H]
 \centering
 \includegraphics[scale=0.6]{./imag13.png}
 \caption{Regras sum}
\end{figure}
\begin{figure}[H]
 \centering
 \includegraphics[scale=0.6]{./imag14.png}
 \caption{Função refresh sum}
\end{figure}


\textbf{sum flag}\\
\begin{verbatim}
Elemento.out_sum_flag = Elemento.in_sum_flag
\end{verbatim}
\begin{figure}[H]
 \centering
 \includegraphics[scale=0.6]{./imag15.png}
 \caption{Regra sum flag}
\end{figure}


\textbf{result}\\
\begin{verbatim}
Elemento.out_result = Elemento.in_result
\end{verbatim}
\begin{figure}[H]
 \centering
 \includegraphics[scale=0.6]{./imag16.png}
 \caption{Regra result}
\end{figure}



\subsubsection{Elemento -> str}
\textbf{sum flag}\\

\begin{verbatim}
Elemento.out_sum_flag = function refresh_sum_flag
\end{verbatim}
Em que a função é definida por:
\begin{verbatim}
        $1 = Elemento.in_sum_flag, $2 = str.value
        int refresh_sum_flag($1, $2){
                if($2.equals(?soma?)) return 1; else return $1;
        }
\end{verbatim}

\begin{figure}[H]
 \centering
 \includegraphics[scale=0.6]{./imag17.png}
 \caption{Regra sum flag}
\end{figure}

\begin{figure}[H]
 \centering
 \includegraphics[scale=0.6]{./imag18.png}
 \caption{Função refresh sum flag}
\end{figure}

\textbf{sum}\\
\begin{verbatim}
Elemento.out_sum = function refresh_sum
\end{verbatim}
Em que a função é definida por:
\begin{verbatim}
        $1 = Elemento.in_sum, $2 = str.value
        int refresh_sum($1,$2){
                if($2.equals(?soma?)) return 0; else return $1; 
        }
\end{verbatim}

\begin{figure}[H]
 \centering
 \includegraphics[scale=0.6]{./imag19.png}
 \caption{Regra sum}
\end{figure}

\begin{figure}[H]
 \centering
 \includegraphics[scale=0.6]{./imag20.png}
 \caption{Função refresh sum}
\end{figure}



\section{Conclusões}
Síntese do Documento.\\
Estado final do projecto. Análise crítica dos resultados.\\
Sugestões para trabalho futuro.


\end{document}
